import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import os
import csv
import chardet
from pathlib import Path
from datetime import datetime
import re
from concurrent.futures import ThreadPoolExecutor, as_completed
from collections import defaultdict
import time
import threading

class ForensicFileViewer:
    def __init__(self, root):
        self.root = root
        self.root.title("í¬ë Œì‹ íŒŒì¼ ë·°ì–´")
        self.root.geometry("1400x900")
        self.selected_folder = None
        self.categories = []
        self.current_category = None
        self.search_results = []
        self.current_search_index = 0
        self.file_tree_data = {}
        self.current_file_path = None
        self.current_file_content = None
        self.view_mode = "table"
        self.file_search_matches = []
        self.current_file_search_index = 0
        self.file_list_data = {}
        self.index_name = defaultdict(set)
        self.index_content = defaultdict(set)
        self.sample_texts = {}
        self.index_lock = threading.Lock()
        self.search_by_name = tk.BooleanVar(master=root, value=True)
        self.search_by_content = tk.BooleanVar(master=root, value=True)
        self.indexing_in_progress = False
        self.indexing_start_time = 0
        self.indexed_count = 0
        self.total_files = 0
        self._csv_sort_state = {}  # â˜… CSV ì •ë ¬ í† ê¸€ ìƒíƒœ ì €ì¥
        self.setup_ui()

    # --------------------------------------------------------
    # UI SETUP
    # --------------------------------------------------------
    def setup_ui(self):
        main_container = tk.Frame(self.root)
        main_container.pack(fill=tk.BOTH, expand=True)

        # -------- HEADER --------
        header_frame = tk.Frame(main_container, bg="#2c3e50", height=50)
        header_frame.pack(fill=tk.X)
        header_frame.pack_propagate(False)

        title_label = tk.Label(header_frame, text="ğŸ” í¬ë Œì‹ íŒŒì¼ ë·°ì–´", bg="#2c3e50", fg="white", font=("ë§‘ì€ ê³ ë”•", 14, "bold"))
        title_label.pack(side=tk.LEFT, padx=20, pady=10)

        select_btn = tk.Button(header_frame, text="ğŸ“ í´ë” ì„ íƒ", command=self.select_folder, bg="#3498db", fg="white", font=("ë§‘ì€ ê³ ë”•", 10), relief=tk.FLAT, padx=15, pady=5, cursor="hand2")
        select_btn.pack(side=tk.RIGHT, padx=20, pady=10)

        # -------- Progress Frame --------
        self.progress_frame = tk.Frame(main_container, bg="#34495e", height=70)
        self.progress_label = tk.Label(self.progress_frame, text="ì¸ë±ì‹± ì¤€ë¹„ ì¤‘...", bg="#34495e", fg="white", font=("ë§‘ì€ ê³ ë”•", 10, "bold"))
        self.progress_label.pack(pady=(10, 5))

        progress_container = tk.Frame(self.progress_frame, bg="#34495e")
        progress_container.pack(fill=tk.X, padx=20, pady=(0, 5))

        self.progress_bar = ttk.Progressbar(progress_container, mode='determinate', length=400, maximum=100)
        self.progress_bar.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=(0, 10))

        self.progress_info = tk.Label(progress_container, text="0 / 0 (0%)", bg="#34495e", fg="#ecf0f1", font=("ë§‘ì€ ê³ ë”•", 9, "bold"), width=20)
        self.progress_info.pack(side=tk.LEFT)

        self.time_info = tk.Label(self.progress_frame, text="ì˜ˆìƒ ì‹œê°„: ê³„ì‚° ì¤‘...", bg="#34495e", fg="#f39c12", font=("ë§‘ì€ ê³ ë”•", 9))
        self.time_info.pack(side=tk.TOP, pady=(0, 10))

        # -------- Category (Top Buttons) --------
        category_frame = tk.Frame(main_container, bg="#ecf0f1", height=45)
        category_frame.pack(fill=tk.X)
        category_frame.pack_propagate(False)

        self.category_canvas = tk.Canvas(category_frame, bg="#ecf0f1", highlightthickness=0, height=45)
        category_scrollbar = tk.Scrollbar(category_frame, orient=tk.HORIZONTAL, command=self.category_canvas.xview)
        self.category_inner_frame = tk.Frame(self.category_canvas, bg="#ecf0f1")

        self.category_canvas_window = self.category_canvas.create_window((0, 0), window=self.category_inner_frame, anchor="nw")
        self.category_canvas.configure(xscrollcommand=category_scrollbar.set)

        self.category_canvas.pack(side=tk.TOP, fill=tk.BOTH, expand=True)
        category_scrollbar.pack(side=tk.BOTTOM, fill=tk.X)

        self.category_inner_frame.bind("<Configure>", lambda e: self.category_canvas.configure(scrollregion=self.category_canvas.bbox("all")))

        # -------- SEARCH BAR --------
        search_frame = tk.Frame(main_container, bg="#f8f9fa", height=45)
        search_frame.pack(fill=tk.X)
        search_frame.pack_propagate(False)

        tk.Label(search_frame, text="ì „ì²´ ê²€ìƒ‰:", bg="#f8f9fa", font=("ë§‘ì€ ê³ ë”•", 9)).pack(side=tk.LEFT, padx=(20, 5), pady=10)

        self.search_entry = tk.Entry(search_frame, font=("ë§‘ì€ ê³ ë”•", 10), width=40)
        self.search_entry.pack(side=tk.LEFT, padx=5, pady=10)
        self.search_entry.bind("<Return>", lambda e: self.search_files())

        search_btn = tk.Button(search_frame, text="ğŸ” ê²€ìƒ‰", command=self.search_files, bg="#28a745", fg="white", font=("ë§‘ì€ ê³ ë”•", 9), relief=tk.FLAT, padx=12, cursor="hand2")
        search_btn.pack(side=tk.LEFT, padx=5, pady=10)

        tk.Checkbutton(search_frame, text="íŒŒì¼ëª… ê²€ìƒ‰", variable=self.search_by_name, bg="#f8f9fa", font=("ë§‘ì€ ê³ ë”•", 9)).pack(side=tk.LEFT, padx=5)
        tk.Checkbutton(search_frame, text="ë‚´ìš© ê²€ìƒ‰", variable=self.search_by_content, bg="#f8f9fa", font=("ë§‘ì€ ê³ ë”•", 9)).pack(side=tk.LEFT, padx=5)

        prev_btn = tk.Button(search_frame, text="â—€ ì´ì „", command=self.prev_search_result, bg="#6c757d", fg="white", font=("ë§‘ì€ ê³ ë”•", 9), relief=tk.FLAT, padx=10, cursor="hand2")
        prev_btn.pack(side=tk.LEFT, padx=2, pady=10)

        next_btn = tk.Button(search_frame, text="ë‹¤ìŒ â–¶", command=self.next_search_result, bg="#6c757d", fg="white", font=("ë§‘ì€ ê³ ë”•", 9), relief=tk.FLAT, padx=10, cursor="hand2")
        next_btn.pack(side=tk.LEFT, padx=2, pady=10)

        self.search_info_label = tk.Label(search_frame, text="", bg="#f8f9fa", font=("ë§‘ì€ ê³ ë”•", 9))
        self.search_info_label.pack(side=tk.LEFT, padx=10)

        # ---------- MAIN PANELS ----------
        self.main_paned = tk.PanedWindow(main_container, orient=tk.VERTICAL, sashrelief=tk.RAISED, sashwidth=5)
        self.main_paned.pack(fill=tk.BOTH, expand=True)

        # -------- TOP PANEL (tree + file list) --------
        top_panel = tk.Frame(self.main_paned)
        self.main_paned.add(top_panel, minsize=300)

        self.top_paned = tk.PanedWindow(top_panel, orient=tk.HORIZONTAL, sashrelief=tk.RAISED, sashwidth=5)
        self.top_paned.pack(fill=tk.BOTH, expand=True)

        # -------- Left: Folder Tree --------
        left_frame = tk.Frame(self.top_paned, bg="#f8f9fa")
        self.top_paned.add(left_frame, minsize=200)

        tree_label = tk.Label(left_frame, text="ğŸ“ í´ë”/íŒŒì¼ íŠ¸ë¦¬", bg="#495057", fg="white", font=("ë§‘ì€ ê³ ë”•", 10, "bold"), anchor="w", padx=10, pady=8)
        tree_label.pack(fill=tk.X)

        tree_scroll_y = tk.Scrollbar(left_frame, orient=tk.VERTICAL)
        tree_scroll_x = tk.Scrollbar(left_frame, orient=tk.HORIZONTAL)

        self.file_tree = ttk.Treeview(left_frame, yscrollcommand=tree_scroll_y.set, xscrollcommand=tree_scroll_x.set)
        tree_scroll_y.config(command=self.file_tree.yview)
        tree_scroll_x.config(command=self.file_tree.xview)

        tree_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        tree_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        self.file_tree.pack(fill=tk.BOTH, expand=True)

        self.file_tree.bind("<<TreeviewSelect>>", self.on_tree_select)
        self.file_tree.bind("<<TreeviewOpen>>", self.on_tree_open)

        # -------- Center: File List --------
        center_frame = tk.Frame(self.top_paned)
        self.top_paned.add(center_frame, minsize=300)

        self.file_list_header = tk.Label(center_frame, text="ğŸ“‚ íŒŒì¼ ëª©ë¡", bg="#495057", fg="white", font=("ë§‘ì€ ê³ ë”•", 10, "bold"), anchor="w", padx=10, pady=8)
        self.file_list_header.pack(fill=tk.X)

        file_list_scroll_y = tk.Scrollbar(center_frame, orient=tk.VERTICAL)
        file_list_scroll_x = tk.Scrollbar(center_frame, orient=tk.HORIZONTAL)

        self.file_listbox = tk.Listbox(center_frame, font=("ë§‘ì€ ê³ ë”•", 9), yscrollcommand=file_list_scroll_y.set, xscrollcommand=file_list_scroll_x.set)

        file_list_scroll_y.config(command=self.file_listbox.yview)
        file_list_scroll_x.config(command=self.file_listbox.xview)

        file_list_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        file_list_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        self.file_listbox.pack(fill=tk.BOTH, expand=True)

        self.file_listbox.bind("<<ListboxSelect>>", self.on_file_select)

        self.path_label = tk.Label(center_frame, text="", anchor="w", font=("ë§‘ì€ ê³ ë”•", 8))
        self.path_label.pack(fill=tk.X, padx=6, pady=4)

        # --------------------------------------------------
        # BOTTOM PANEL (Content viewer)
        # --------------------------------------------------
        bottom_frame = tk.Frame(self.main_paned)
        self.main_paned.add(bottom_frame, minsize=200)

        # -------- Content Header --------
        content_header = tk.Frame(bottom_frame, bg="#6c757d", height=35)
        content_header.pack(fill=tk.X)
        content_header.pack_propagate(False)

        self.content_title_label = tk.Label(content_header, text="ğŸ“„ íŒŒì¼ ë‚´ìš©", bg="#6c757d", fg="white", font=("ë§‘ì€ ê³ ë”•", 9, "bold"))
        self.content_title_label.pack(side=tk.LEFT, padx=10, pady=8)

        view_mode_frame = tk.Frame(content_header, bg="#6c757d")
        view_mode_frame.pack(side=tk.RIGHT, padx=10)

        self.table_btn = tk.Button(view_mode_frame, text="í‘œ", command=lambda: self.change_view_mode("table"), bg="#495057", fg="white", font=("ë§‘ì€ ê³ ë”•", 8), relief=tk.FLAT, padx=8, cursor="hand2")
        self.table_btn.pack(side=tk.LEFT, padx=2)

        self.text_btn = tk.Button(view_mode_frame, text="í…ìŠ¤íŠ¸", command=lambda: self.change_view_mode("text"), bg="#343a40", fg="white", font=("ë§‘ì€ ê³ ë”•", 8), relief=tk.FLAT, padx=8, cursor="hand2")
        self.text_btn.pack(side=tk.LEFT, padx=2)

        self.hex_btn = tk.Button(view_mode_frame, text="HEX", command=lambda: self.change_view_mode("hex"), bg="#343a40", fg="white", font=("ë§‘ì€ ê³ ë”•", 8), relief=tk.FLAT, padx=8, cursor="hand2")
        self.hex_btn.pack(side=tk.LEFT, padx=2)

        # -------- File Search (bottom) --------
        file_search_frame = tk.Frame(bottom_frame, bg="#e9ecef", height=40)
        file_search_frame.pack(fill=tk.X)
        file_search_frame.pack_propagate(False)

        tk.Label(file_search_frame, text="íŒŒì¼ ë‚´ ê²€ìƒ‰:", bg="#e9ecef", font=("ë§‘ì€ ê³ ë”•", 9)).pack(side=tk.LEFT, padx=(10, 5), pady=8)

        self.file_search_entry = tk.Entry(file_search_frame, font=("ë§‘ì€ ê³ ë”•", 9), width=30)
        self.file_search_entry.pack(side=tk.LEFT, padx=5, pady=8)
        self.file_search_entry.bind("<Return>", lambda e: self.search_in_file())

        file_search_btn = tk.Button(file_search_frame, text="ì°¾ê¸°", command=self.search_in_file, bg="#17a2b8", fg="white", font=("ë§‘ì€ ê³ ë”•", 8), relief=tk.FLAT, padx=10, cursor="hand2")
        file_search_btn.pack(side=tk.LEFT, padx=5, pady=8)

        file_prev_btn = tk.Button(file_search_frame, text="â—€", command=self.prev_file_search, bg="#6c757d", fg="white", font=("ë§‘ì€ ê³ ë”•", 8), relief=tk.FLAT, padx=8, cursor="hand2")
        file_prev_btn.pack(side=tk.LEFT, padx=2, pady=8)

        file_next_btn = tk.Button(file_search_frame, text="â–¶", command=self.next_file_search, bg="#6c757d", fg="white", font=("ë§‘ì€ ê³ ë”•", 8), relief=tk.FLAT, padx=8, cursor="hand2")
        file_next_btn.pack(side=tk.LEFT, padx=2, pady=8)

        self.file_search_info = tk.Label(file_search_frame, text="", bg="#e9ecef", font=("ë§‘ì€ ê³ ë”•", 9))
        self.file_search_info.pack(side=tk.LEFT, padx=10)

        # -------- Content Container (table + text + hex) --------
        content_container = tk.Frame(bottom_frame)
        content_container.pack(fill=tk.BOTH, expand=True)

        # -------- TABLE VIEW --------
        self.table_frame = tk.Frame(content_container)
        table_scroll_y = tk.Scrollbar(self.table_frame, orient=tk.VERTICAL)
        table_scroll_x = tk.Scrollbar(self.table_frame, orient=tk.HORIZONTAL)

        self.content_tree = ttk.Treeview(self.table_frame, yscrollcommand=table_scroll_y.set, xscrollcommand=table_scroll_x.set)
        table_scroll_y.config(command=self.content_tree.yview)
        table_scroll_x.config(command=self.content_tree.xview)

        table_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        table_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        self.content_tree.pack(fill=tk.BOTH, expand=True)

        self.content_tree.tag_configure("highlight", background="yellow", foreground="black")

        # -------- TEXT VIEW --------
        self.text_frame = tk.Frame(content_container)
        text_scroll_y = tk.Scrollbar(self.text_frame, orient=tk.VERTICAL)
        text_scroll_x = tk.Scrollbar(self.text_frame, orient=tk.HORIZONTAL)

        self.content_text = tk.Text(self.text_frame, wrap=tk.NONE, font=("Consolas", 9), yscrollcommand=text_scroll_y.set, xscrollcommand=text_scroll_x.set)

        text_scroll_y.config(command=self.content_text.yview)
        text_scroll_x.config(command=self.content_text.xview)

        text_scroll_y.pack(side=tk.RIGHT, fill=tk.Y)
        text_scroll_x.pack(side=tk.BOTTOM, fill=tk.X)
        self.content_text.pack(fill=tk.BOTH, expand=True)

        self.content_text.tag_configure("highlight", background="yellow", foreground="black")

        self.table_frame.pack(fill=tk.BOTH, expand=True)

    # --------------------------------------------------------
    # FOLDER SELECT + CATEGORY LOAD
    # --------------------------------------------------------
    def select_folder(self):
        folder = filedialog.askdirectory(title="í´ë” ì„ íƒ")
        if folder:
            self.selected_folder = folder
            self.load_categories()
            self.build_index_async()

    def load_categories(self):
        if not self.selected_folder:
            return

        for widget in self.category_inner_frame.winfo_children():
            widget.destroy()

        self.categories = []

        try:
            items = os.listdir(self.selected_folder)
            for item in items:
                item_path = os.path.join(self.selected_folder, item)
                if os.path.isdir(item_path):
                    self.categories.append(item)

            for idx, category in enumerate(self.categories):
                btn = tk.Button(
                    self.category_inner_frame,
                    text=f"ğŸ“‚ {category}",
                    command=lambda c=category: self.select_category(c),
                    bg="white",
                    font=("ë§‘ì€ ê³ ë”•", 9),
                    relief=tk.RAISED,
                    padx=15,
                    pady=8,
                    cursor="hand2"
                )
                btn.pack(side=tk.LEFT, padx=3, pady=5)

            if self.categories:
                self.select_category(self.categories[0])
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"í´ë” ë¡œë“œ ì‹¤íŒ¨: {str(e)}")

    def select_category(self, category):
        self.current_category = category

        for widget in self.category_inner_frame.winfo_children():
            if isinstance(widget, tk.Button):
                if widget["text"] == f"ğŸ“‚ {category}":
                    widget.config(bg="#2980b9", fg="white")
                else:
                    widget.config(bg="white", fg="black")

        self.file_tree.delete(*self.file_tree.get_children())
        category_path = os.path.join(self.selected_folder, category)
        self.insert_tree_node("", category_path)

    # --------------------------------------------------------
    # TREEVIEW FOLDER LOAD
    # --------------------------------------------------------
    def insert_tree_node(self, parent, path):
        name = os.path.basename(path)
        node = self.file_tree.insert(parent, "end", text=f"ğŸ“ {name}", values=(path,), tags=("dir",))

        try:
            if any(os.scandir(path)):
                self.file_tree.insert(node, "end", text="...", values=("",), tags=("placeholder",))
        except Exception:
            pass

    def on_tree_open(self, event):
        selected = self.file_tree.selection()
        for item in selected:
            if "dir" in self.file_tree.item(item, "tags"):
                children = self.file_tree.get_children(item)
                if children:
                    first = children[0]
                    if "placeholder" in self.file_tree.item(first, "tags"):
                        self.file_tree.delete(first)
                        path = self.file_tree.item(item, "values")[0]

                        try:
                            with os.scandir(path) as it:
                                entries = sorted(it, key=lambda e: (not e.is_dir(), e.name.lower()))
                                for entry in entries:
                                    entry_path = entry.path

                                    if entry.is_dir():
                                        child = self.file_tree.insert(item, "end", text=f"ğŸ“ {entry.name}", values=(entry_path,), tags=("dir",))
                                        try:
                                            if any(os.scandir(entry_path)):
                                                self.file_tree.insert(child, "end", text="...", values=("",), tags=("placeholder",))
                                        except Exception:
                                            pass
                                    else:
                                        self.file_tree.insert(item, "end", text=f"ğŸ“„ {entry.name}", values=(entry_path,), tags=("file",))
                        except Exception:
                            pass

    def on_tree_select(self, event):
        selection = self.file_tree.selection()
        if not selection:
            return
        item = selection[0]

        values = self.file_tree.item(item, "values")
        if values:
            path = values[0]
            if os.path.isdir(path):
                self.load_file_list(path)
            else:
                self.display_file(path)

    # --------------------------------------------------------
    # FILE LIST LOAD
    # --------------------------------------------------------
    def load_file_list(self, folder_path):
        self.file_listbox.delete(0, tk.END)
        self.file_list_data.clear()

        folder_name = os.path.basename(folder_path)

        try:
            items = os.listdir(folder_path)
            files = [f for f in items if os.path.isfile(os.path.join(folder_path, f))]
            files.sort()

            self.file_list_header.config(text=f"ğŸ“‚ {folder_name} ({len(files)}ê°œ íŒŒì¼)")

            for idx, file in enumerate(files):
                file_path = os.path.join(folder_path, file)
                size = os.path.getsize(file_path)
                size_str = self.format_size(size)

                display = f"ğŸ“„ {file}  ({size_str})"
                self.file_listbox.insert(tk.END, display)
                self.file_list_data[idx] = file_path

            self.path_label.config(text="")
        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"íŒŒì¼ ëª©ë¡ ë¡œë“œ ì‹¤íŒ¨: {str(e)}")

    def format_size(self, size):
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024.0:
                return f"{size:.1f} {unit}"
            size /= 1024.0
        return f"{size:.1f} TB"

    def on_file_select(self, event):
        selection = self.file_listbox.curselection()
        if not selection:
            return

        idx = selection[0]
        file_path = self.file_list_data.get(idx)

        if file_path:
            self.path_label.config(text=f"ê²½ë¡œ: {file_path}")
            self.display_file(file_path)

    # --------------------------------------------------------
    # FILE DISPLAY (CSV, TEXT, HEX)
    # --------------------------------------------------------
    def display_file(self, file_path):
        self.current_file_path = file_path
        file_name = os.path.basename(file_path)

        self.content_title_label.config(text=f"ğŸ“„ {file_name}")

        self.file_search_matches = []
        self.current_file_search_index = 0
        self.file_search_info.config(text="")

        try:
            file_ext = os.path.splitext(file_path)[1].lower()

            if file_ext == '.csv':
                self.view_mode = "table"
                self.display_csv(file_path)
            else:
                self.view_mode = "text"
                self.display_text(file_path)

            self.update_view_buttons()

        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"íŒŒì¼ í‘œì‹œ ì‹¤íŒ¨: {str(e)}")

    # ---------------- CSV VIEW (ì •ë ¬ í¬í•¨) ----------------
    def display_csv(self, file_path):
        self.text_frame.pack_forget()
        self.table_frame.pack(fill=tk.BOTH, expand=True)

        self.content_tree.delete(*self.content_tree.get_children())

        encoding = self.detect_encoding(file_path)

        try:
            with open(file_path, 'r', encoding=encoding, errors='ignore') as f:
                reader = csv.reader(f)
                rows = list(reader)

            if not rows:
                return

            headers = [h.strip() for h in rows[0]]

            self.content_tree["columns"] = headers
            self.content_tree["show"] = "tree headings"
            self.content_tree.column("#0", width=50, stretch=False)
            self.content_tree.heading("#0", text="No")

            # â˜… í—¤ë” í´ë¦­ â†’ ì •ë ¬ ê¸°ëŠ¥ ì—°ê²°
            for col in headers:
                self.content_tree.column(col, width=150, anchor="w")
                self.content_tree.heading(col, text=col, command=lambda c=col: self.sort_csv_column(c))

            # ë³¸ë¬¸ ì‚½ì…
            for idx, row in enumerate(rows[1:], 1):
                row_data = row + [""] * (len(headers) - len(row))
                row_data = row_data[:len(headers)]
                self.content_tree.insert("", "end", text=str(idx), values=row_data)

            self.current_file_content = rows  # ì›ë³¸ ì €ì¥ (ì •ë ¬ì— í•„ìš”)

        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"CSV ë¡œë“œ ì‹¤íŒ¨: {str(e)}")

    # ---------------- CSV ì •ë ¬ í•¨ìˆ˜ ----------------
    def sort_csv_column(self, column):
        if not self.current_file_content:
            return

        rows = self.current_file_content[1:]
        headers = self.current_file_content[0]

        if column not in headers:
            return

        idx = headers.index(column)

        def convert(v):
            patterns = [
                "%Y-%m-%d %H:%M:%S",
                "%Y-%m-%d",
                "%Y/%m/%d %H:%M:%S",
                "%Y/%m/%d",
            ]
            for p in patterns:
                try:
                    return datetime.strptime(v, p)
                except:
                    pass
            try:
                return float(v)
            except:
                pass
            return v

        reverse = self._csv_sort_state.get(column, False)
        self._csv_sort_state[column] = not reverse

        rows_sorted = sorted(rows, key=lambda r: convert(r[idx]) if idx < len(r) else "", reverse=reverse)

        self.content_tree.delete(*self.content_tree.get_children())

        for i, row in enumerate(rows_sorted, 1):
            fixed = row + [""] * (len(headers) - len(row))
            fixed = fixed[:len(headers)]
            self.content_tree.insert("", "end", text=str(i), values=fixed)

    # ---------------- TEXT VIEW ----------------
    def display_text(self, file_path):
        self.table_frame.pack_forget()
        self.text_frame.pack(fill=tk.BOTH, expand=True)

        self.content_text.delete(1.0, tk.END)
        encoding = self.detect_encoding(file_path)

        try:
            file_size = os.path.getsize(file_path)
            max_size = 10 * 1024 * 1024

            if file_size > max_size:
                with open(file_path, 'rb') as f:
                    content = f.read(max_size)

                try:
                    text = content.decode(encoding, errors='ignore')
                    text += f"\n\n[íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤. ì²˜ìŒ 10MBë§Œ í‘œì‹œë©ë‹ˆë‹¤.]"
                except:
                    text = self.to_hex(content)
                    text += f"\n\n[íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤. ì²˜ìŒ 10MBë§Œ í‘œì‹œë©ë‹ˆë‹¤.]"
            else:
                with open(file_path, 'r', encoding=encoding, errors='ignore') as f:
                    text = f.read()

            self.content_text.insert(1.0, text)
            self.current_file_content = text

        except Exception:
            try:
                with open(file_path, 'rb') as f:
                    content = f.read(10 * 1024 * 1024)

                hex_text = self.to_hex(content)
                hex_text += f"\n\n[ë°”ì´ë„ˆë¦¬ í‘œì‹œ]"
                self.content_text.insert(1.0, hex_text)

                self.current_file_content = hex_text
                self.view_mode = "hex"
                self.update_view_buttons()

            except Exception as e2:
                messagebox.showerror("ì˜¤ë¥˜", f"íŒŒì¼ í‘œì‹œ ì‹¤íŒ¨: {str(e2)}")

    # ---------------- HEX VIEW ----------------
    def display_hex_view(self):
        self.table_frame.pack_forget()
        self.text_frame.pack(fill=tk.BOTH, expand=True)

        self.content_text.delete(1.0, tk.END)

        try:
            max_size = 10 * 1024 * 1024
            file_size = os.path.getsize(self.current_file_path)

            with open(self.current_file_path, 'rb') as f:
                content = f.read(max_size if file_size > max_size else file_size)

            hex_text = self.to_hex(content)

            if file_size > max_size:
                hex_text += f"\n\n[íŒŒì¼ì´ ë„ˆë¬´ í½ë‹ˆë‹¤. ì²˜ìŒ 10MBë§Œ í‘œì‹œë©ë‹ˆë‹¤.]"

            self.content_text.insert(1.0, hex_text)

        except Exception as e:
            messagebox.showerror("ì˜¤ë¥˜", f"HEX ë·° í‘œì‹œ ì‹¤íŒ¨: {str(e)}")

    def to_hex(self, data):
        hex_lines = []
        for i in range(0, len(data), 16):
            chunk = data[i:i+16]
            hex_part = ' '.join(f'{b:02X}' for b in chunk)
            ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
            hex_lines.append(f"{i:08X}  {hex_part:<48}  {ascii_part}")
        return '\n'.join(hex_lines)

    def detect_encoding(self, file_path):
        try:
            with open(file_path, 'rb') as f:
                raw_data = f.read(10000)
                result = chardet.detect(raw_data)
                return result['encoding'] or 'utf-8'
        except:
            return 'utf-8'

    # --------------------------------------------------------
    # VIEW MODE CHANGE
    # --------------------------------------------------------
    def change_view_mode(self, mode):
        if not self.current_file_path:
            return

        self.view_mode = mode

        if mode == "table":
            if self.current_file_path.endswith('.csv'):
                self.display_csv(self.current_file_path)
            else:
                messagebox.showinfo("ì•Œë¦¼", "CSV íŒŒì¼ë§Œ í‘œ í˜•ì‹ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
                return
        elif mode == "text":
            self.display_text(self.current_file_path)
        elif mode == "hex":
            self.display_hex_view()

        self.update_view_buttons()

    def update_view_buttons(self):
        self.table_btn.config(bg="#343a40" if self.view_mode != "table" else "#495057")
        self.text_btn.config(bg="#343a40" if self.view_mode != "text" else "#495057")
        self.hex_btn.config(bg="#343a40" if self.view_mode != "hex" else "#495057")

    # --------------------------------------------------------
    # INDEXING
    # --------------------------------------------------------
    def update_progress_ui(self):
        if not self.indexing_in_progress:
            return

        try:
            with self.index_lock:
                current_count = self.indexed_count
                total = self.total_files

            if total > 0:
                percentage = (current_count / total) * 100
                self.progress_bar['value'] = percentage
                self.progress_info.config(text=f"{current_count} / {total} ({percentage:.1f}%)")

                elapsed = time.time() - self.indexing_start_time

                if current_count > 0:
                    avg_time_per_file = elapsed / current_count
                    remaining_files = total - current_count
                    estimated_remaining = avg_time_per_file * remaining_files

                    if estimated_remaining < 60:
                        time_str = f"{int(estimated_remaining)}ì´ˆ"
                    elif estimated_remaining < 3600:
                        minutes = int(estimated_remaining / 60)
                        seconds = int(estimated_remaining % 60)
                        time_str = f"{minutes}ë¶„ {seconds}ì´ˆ"
                    else:
                        hours = int(estimated_remaining / 3600)
                        minutes = int((estimated_remaining % 3600) / 60)
                        time_str = f"{hours}ì‹œê°„ {minutes}ë¶„"

                    self.time_info.config(text=f"ì˜ˆìƒ ì‹œê°„: {time_str}")

                else:
                    self.time_info.config(text="ì˜ˆìƒ ì‹œê°„: ê³„ì‚° ì¤‘...")

            if self.indexing_in_progress:
                self.root.after(200, self.update_progress_ui)

        except:
            pass

    def build_index_async(self):
        with self.index_lock:
            self.index_name.clear()
            self.index_content.clear()
            self.sample_texts.clear()

        folder = self.selected_folder
        if not folder:
            return

        paths = []
        for root, dirs, files in os.walk(folder):
            for f in files:
                paths.append(os.path.join(root, f))

        if not paths:
            return

        with self.index_lock:
            self.total_files = len(paths)
            self.indexed_count = 0
            self.indexing_in_progress = True
            self.indexing_start_time = time.time()

        self.progress_frame.pack(after=self.root.winfo_children()[0].winfo_children()[0], fill=tk.X)
        self.progress_bar['value'] = 0

        self.progress_label.config(text=f"ì¸ë±ì‹± ì¤‘... (ì´ {self.total_files}ê°œ íŒŒì¼)")
        self.progress_info.config(text=f"0 / {self.total_files} (0%)")
        self.time_info.config(text="ì˜ˆìƒ ì‹œê°„: ê³„ì‚° ì¤‘...")

        self.root.after(200, self.update_progress_ui)

        def worker(path):
            try:
                name = os.path.basename(path).lower()

                with self.index_lock:
                    self.index_name[name].add(path)

                small = b""

                try:
                    size = os.path.getsize(path)
                    read_size = min(200000, size)

                    with open(path, 'rb') as fh:
                        small = fh.read(read_size)

                    enc = chardet.detect(small).get('encoding') or 'utf-8'
                    text = small.decode(enc, errors='ignore')

                    with self.index_lock:
                        self.sample_texts[path] = text

                    tokens = set(re.findall(r'\w{2,}', text.lower()))
                    with self.index_lock:
                        for t in tokens:
                            self.index_content[t].add(path)

                except Exception:
                    pass

                tokens_name = set(re.findall(r'\w{2,}', name))
                with self.index_lock:
                    for t in tokens_name:
                        self.index_content[t].add(path)

            except Exception:
                pass

            finally:
                with self.index_lock:
                    self.indexed_count += 1

        def indexing_complete():
            with self.index_lock:
                self.indexing_in_progress = False
                total = self.total_files

            elapsed = time.time() - self.indexing_start_time

            if elapsed < 60:
                time_str = f"{elapsed:.1f}ì´ˆ"
            else:
                minutes = int(elapsed / 60)
                seconds = int(elapsed % 60)
                time_str = f"{minutes}ë¶„ {seconds}ì´ˆ"

            self.progress_label.config(text=f"âœ“ ì¸ë±ì‹± ì™„ë£Œ! (ì´ {total}ê°œ íŒŒì¼, ì†Œìš” ì‹œê°„: {time_str})")
            self.progress_bar['value'] = 100
            self.progress_info.config(text=f"{total} / {total} (100%)")
            self.time_info.config(text="ì™„ë£Œ")

            self.root.after(3000, lambda: self.progress_frame.pack_forget())

        def run_indexing():
            try:
                with ThreadPoolExecutor(max_workers=8) as ex:
                    futures = [ex.submit(worker, p) for p in paths]
                    for _ in as_completed(futures):
                        pass

                self.root.after(0, indexing_complete)

            except Exception as e:
                print(f"ì¸ë±ì‹± ì˜¤ë¥˜: {e}")

                with self.index_lock:
                    self.indexing_in_progress = False

                self.root.after(0, lambda: messagebox.showerror("ì˜¤ë¥˜", f"ì¸ë±ì‹± ì‹¤íŒ¨: {str(e)}"))

        index_thread = threading.Thread(target=run_indexing, daemon=True)
        index_thread.start()

    # --------------------------------------------------------
    # GLOBAL SEARCH
    # --------------------------------------------------------
    def search_files(self):
        search_text = self.search_entry.get().strip()
        if not search_text:
            messagebox.showwarning("ê²½ê³ ", "ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
            return

        if not self.selected_folder:
            messagebox.showwarning("ê²½ê³ ", "ë¨¼ì € í´ë”ë¥¼ ì„ íƒí•˜ì„¸ìš”.")
            return

        with self.index_lock:
            if self.indexing_in_progress:
                messagebox.showwarning("ê²½ê³ ", "ì¸ë±ì‹±ì´ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
                return

        do_name = self.search_by_name.get()
        do_content = self.search_by_content.get()

        if not do_name and not do_content:
            messagebox.showwarning("ê²½ê³ ", "íŒŒì¼ëª… ê²€ìƒ‰ ë˜ëŠ” ë‚´ìš© ê²€ìƒ‰ ì¤‘ í•˜ë‚˜ ì´ìƒ ì„ íƒí•˜ì„¸ìš”.")
            return

        lowered = search_text.lower()
        pattern = re.compile(re.escape(search_text), re.IGNORECASE)

        name_candidates = set()
        content_candidates = set()

        # -------- íŒŒì¼ëª… ê²€ìƒ‰ --------
        if do_name:
            with self.index_lock:
                for name, paths in self.index_name.items():
                    if lowered in name:
                        name_candidates.update(paths)

        # -------- ë‚´ìš© ê²€ìƒ‰ --------
        if do_content:
            tokens = re.findall(r'\w{2,}', lowered)
            rough = set()

            if tokens:
                with self.index_lock:
                    for t in tokens:
                        if t in self.index_content:
                            rough.update(self.index_content[t])

            candidates = rough | name_candidates if do_name else rough

            def verify(path):
                try:
                    if os.path.getsize(path) > 50 * 1024 * 1024:
                        return None

                    with self.index_lock:
                        text = self.sample_texts.get(path)

                    if text is None:
                        with open(path, 'rb') as f:
                            raw = f.read(200000)
                        enc = chardet.detect(raw).get('encoding') or 'utf-8'
                        text = raw.decode(enc, errors='ignore')

                    if pattern.search(text):
                        return {'path': path, 'content': text}

                except:
                    return None

            with ThreadPoolExecutor(max_workers=8) as ex:
                futures = {ex.submit(verify, p): p for p in candidates}

                for fut in as_completed(futures):
                    r = fut.result()
                    if r:
                        content_candidates.add(r['path'])

        final_paths = sorted(name_candidates | content_candidates)

        if not final_paths:
            self.search_results = []
            self.search_info_label.config(text="ê²€ìƒ‰ ê²°ê³¼ ì—†ìŒ")
            messagebox.showinfo("ê²€ìƒ‰ ì™„ë£Œ", "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.")
            return

        with self.index_lock:
            self.search_results = [{'path': p, 'content': self.sample_texts.get(p, '')} for p in final_paths]

        self.search_info_label.config(text=f"ê²€ìƒ‰ ê²°ê³¼: {len(self.search_results)}ê°œ íŒŒì¼ (1/{len(self.search_results)})")

        self.add_search_category()
        self.show_search_result(0)

        messagebox.showinfo("ê²€ìƒ‰ ì™„ë£Œ", f"{len(self.search_results)}ê°œ íŒŒì¼ì—ì„œ '{search_text}'ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.")

    def add_search_category(self):
        for widget in self.category_inner_frame.winfo_children():
            if isinstance(widget, tk.Button) and "ğŸ” ê²€ìƒ‰ ê²°ê³¼" in widget["text"]:
                widget.destroy()

        search_btn = tk.Button(
            self.category_inner_frame,
            text="ğŸ” ê²€ìƒ‰ ê²°ê³¼",
            command=self.show_search_results_tree,
            bg="#f39c12",
            fg="white",
            font=("ë§‘ì€ ê³ ë”•", 9),
            relief=tk.RAISED,
            padx=15,
            pady=8,
            cursor="hand2"
        )
        search_btn.pack(side=tk.LEFT, padx=3, pady=5)

    def show_search_results_tree(self):
        self.file_tree.delete(*self.file_tree.get_children())

        for idx, result in enumerate(self.search_results, 1):
            file_name = os.path.basename(result['path'])
            rel_path = os.path.relpath(result['path'], self.selected_folder)

            self.file_tree.insert("", "end", text=f"ğŸ“„ {rel_path}", values=(result['path'],))

        for widget in self.category_inner_frame.winfo_children():
            if isinstance(widget, tk.Button):
                if "ğŸ” ê²€ìƒ‰ ê²°ê³¼" in widget["text"]:
                    widget.config(bg="#f39c12", fg="white")
                else:
                    widget.config(bg="white", fg="black")

    # --------------------------------------------------------
    # SEARCH RESULT NAVIGATION
    # --------------------------------------------------------
    def show_search_result(self, index):
        if not self.search_results or index < 0 or index >= len(self.search_results):
            return

        result = self.search_results[index]

        self.display_file(result['path'])

        search_text = self.search_entry.get().strip()
        self.highlight_search_text(search_text)

        self.current_search_index = index
        self.search_info_label.config(text=f"ê²€ìƒ‰ ê²°ê³¼: {len(self.search_results)}ê°œ íŒŒì¼ ({index + 1}/{len(self.search_results)})")

    def highlight_search_text(self, search_text):
        if not search_text:
            return

        if self.view_mode == "table":
            self.highlight_in_table(search_text)
        else:
            self.highlight_in_text(search_text)

    def highlight_in_table(self, search_text):
        for item in self.content_tree.get_children():
            self.content_tree.item(item, tags=())

        pattern = re.compile(re.escape(search_text), re.IGNORECASE)

        for item in self.content_tree.get_children():
            values = self.content_tree.item(item, "values")
            row_text = " ".join(str(v) for v in values)

            if pattern.search(row_text):
                self.content_tree.item(item, tags=("highlight",))

    def highlight_in_text(self, search_text):
        self.content_text.tag_remove("highlight", "1.0", tk.END)
        pattern = re.compile(re.escape(search_text), re.IGNORECASE)

        content = self.content_text.get("1.0", tk.END)

        for match in pattern.finditer(content):
            start_idx = match.start()
            end_idx = match.end()

            start_pos = f"1.0+{start_idx}c"
            end_pos = f"1.0+{end_idx}c"

            self.content_text.tag_add("highlight", start_pos, end_pos)

        first_match = pattern.search(content)
        if first_match:
            first_pos = f"1.0+{first_match.start()}c"
            self.content_text.see(first_pos)

    def prev_search_result(self):
        if not self.search_results:
            return

        self.current_search_index = (self.current_search_index - 1) % len(self.search_results)
        self.show_search_result(self.current_search_index)

    def next_search_result(self):
        if not self.search_results:
            return

        self.current_search_index = (self.current_search_index + 1) % len(self.search_results)
        self.show_search_result(self.current_search_index)

    # --------------------------------------------------------
    # FILE INTERNAL SEARCH
    # --------------------------------------------------------
    def search_in_file(self):
        search_text = self.file_search_entry.get().strip()

        if not search_text:
            messagebox.showwarning("ê²½ê³ ", "ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.")
            return

        if not self.current_file_path:
            messagebox.showwarning("ê²½ê³ ", "ë¨¼ì € íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.")
            return

        self.file_search_matches = []
        self.current_file_search_index = 0

        pattern = re.compile(re.escape(search_text), re.IGNORECASE)

        if self.view_mode == "table":
            self.search_in_table(pattern, search_text)
        else:
            self.search_in_text_widget(pattern, search_text)

    def search_in_table(self, pattern, search_text):
        for item in self.content_tree.get_children():
            self.content_tree.item(item, tags=())

        for item in self.content_tree.get_children():
            values = self.content_tree.item(item, "values")
            row_text = " ".join(str(v) for v in values)

            if pattern.search(row_text):
                self.content_tree.item(item, tags=("highlight",))
                self.file_search_matches.append(item)

        match_count = len(self.file_search_matches)

        if match_count > 0:
            self.file_search_info.config(text=f"ê²°ê³¼: {match_count}ê°œ (1/{match_count})")

            first_item = self.file_search_matches[0]
            self.content_tree.selection_set(first_item)
            self.content_tree.see(first_item)

            self.current_file_search_index = 0
        else:
            self.file_search_info.config(text="ê²°ê³¼ ì—†ìŒ")
            messagebox.showinfo("ê²€ìƒ‰", "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.")

    def search_in_text_widget(self, pattern, search_text):
        self.content_text.tag_remove("highlight", "1.0", tk.END)
        self.file_search_matches = []

        content = self.content_text.get("1.0", tk.END)

        for match in pattern.finditer(content):
            start_idx = match.start()
            start_pos = f"1.0+{start_idx}c"
            end_pos = f"1.0+{match.end()}c"

            self.content_text.tag_add("highlight", start_pos, end_pos)
            self.file_search_matches.append(start_pos)

        match_count = len(self.file_search_matches)

        if match_count > 0:
            self.file_search_info.config(text=f"ê²°ê³¼: {match_count}ê°œ (1/{match_count})")

            self.content_text.see(self.file_search_matches[0])
            self.current_file_search_index = 0
        else:
            self.file_search_info.config(text="ê²°ê³¼ ì—†ìŒ")
            messagebox.showinfo("ê²€ìƒ‰", "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.")

    def prev_file_search(self):
        if not self.file_search_matches:
            return

        self.current_file_search_index = (self.current_file_search_index - 1) % len(self.file_search_matches)

        if self.view_mode == "table":
            item = self.file_search_matches[self.current_file_search_index]
            self.content_tree.selection_set(item)
            self.content_tree.see(item)
        else:
            pos = self.file_search_matches[self.current_file_search_index]
            self.content_text.see(pos)

        self.file_search_info.config(text=f"ê²°ê³¼: {len(self.file_search_matches)}ê°œ ({self.current_file_search_index + 1}/{len(self.file_search_matches)})")

    def next_file_search(self):
        if not self.file_search_matches:
            return

        self.current_file_search_index = (self.current_file_search_index + 1) % len(self.file_search_matches)

        if self.view_mode == "table":
            item = self.file_search_matches[self.current_file_search_index]
            self.content_tree.selection_set(item)
            self.content_tree.see(item)
        else:
            pos = self.file_search_matches[self.current_file_search_index]
            self.content_text.see(pos)

        self.file_search_info.config(text=f"ê²°ê³¼: {len(self.file_search_matches)}ê°œ ({self.current_file_search_index + 1}/{len(self.file_search_matches)})")

# --------------------------------------------------------
# MAIN
# --------------------------------------------------------
def main():
    root = tk.Tk()
    app = ForensicFileViewer(root)
    root.mainloop()

if __name__ == "__main__":
    main()
